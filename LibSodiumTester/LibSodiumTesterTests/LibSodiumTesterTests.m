//
//  LibSodiumTesterTests.m
//  LibSodiumTesterTests
//
//  Created by Drew Crawford on 2/15/14.
//  Modified by Joseph Zurowski on 10/11/20
//  Copyright (c) 2014 DrewCrawfordApps. All rights reserved.
//  Maintained 2020 Dunkel Web Services LLC. https://dws.llc/
//

#import <XCTest/XCTest.h>
#import <sodium.h>
#include <stdio.h>

@interface LibSodiumTesterTests : XCTestCase

@end

@implementation LibSodiumTesterTests

- (void)setUp
{
    [super setUp];
    // Put setup code here. This method is called before the invocation of each test method in the class.
}

- (void)tearDown
{
    // Put teardown code here. This method is called after the invocation of each test method in the class.
    [super tearDown];
}

-(NSString*) stringForTest:(NSString*) test {
    NSBundle *testBundle = nil;
    for (NSBundle *bundle in [NSBundle allBundles]) {
        if ([bundle.bundlePath hasSuffix:@"xctest"]) {
            testBundle = bundle;
            break;
        }
    }
    NSString *path = [testBundle pathForResource:test ofType:@"exp"];
    NSString *compare2 = [[NSString alloc] initWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil];
    return compare2;
}

- (void)testBox
{
    
    
    NSMutableString *compare1 = [[NSMutableString alloc] init];
    unsigned char alicesk[32] = {
        0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d
        ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45
        ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a
        ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a
    } ;
    
    unsigned char bobpk[32] = {
        0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4
        ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37
        ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d
        ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f
    } ;
    
    unsigned char nonce[24] = {
        0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73
        ,0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6
        ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37
    } ;
    
    // API requires first 32 bytes to be 0
    unsigned char m[163] = {
        0,   0,   0,   0,   0,   0,   0,   0
        ,   0,   0,   0,   0,   0,   0,   0,   0
        ,   0,   0,   0,   0,   0,   0,   0,   0
        ,   0,   0,   0,   0,   0,   0,   0,   0
        ,0xbe,0x07,0x5f,0xc5,0x3c,0x81,0xf2,0xd5
        ,0xcf,0x14,0x13,0x16,0xeb,0xeb,0x0c,0x7b
        ,0x52,0x28,0xc5,0x2a,0x4c,0x62,0xcb,0xd4
        ,0x4b,0x66,0x84,0x9b,0x64,0x24,0x4f,0xfc
        ,0xe5,0xec,0xba,0xaf,0x33,0xbd,0x75,0x1a
        ,0x1a,0xc7,0x28,0xd4,0x5e,0x6c,0x61,0x29
        ,0x6c,0xdc,0x3c,0x01,0x23,0x35,0x61,0xf4
        ,0x1d,0xb6,0x6c,0xce,0x31,0x4a,0xdb,0x31
        ,0x0e,0x3b,0xe8,0x25,0x0c,0x46,0xf0,0x6d
        ,0xce,0xea,0x3a,0x7f,0xa1,0x34,0x80,0x57
        ,0xe2,0xf6,0x55,0x6a,0xd6,0xb1,0x31,0x8a
        ,0x02,0x4a,0x83,0x8f,0x21,0xaf,0x1f,0xde
        ,0x04,0x89,0x77,0xeb,0x48,0xf5,0x9f,0xfd
        ,0x49,0x24,0xca,0x1c,0x60,0x90,0x2e,0x52
        ,0xf0,0xa0,0x89,0xbc,0x76,0x89,0x70,0x40
        ,0xe0,0x82,0xf9,0x37,0x76,0x38,0x48,0x64
        ,0x5e,0x07,0x05
    } ;
    
    unsigned char c[163];
        int i;
        crypto_box_curve25519xsalsa20poly1305(
                                              c,m,163,nonce,bobpk,alicesk
                                              );
        for (i = 16;i < 163;++i) {
            [compare1 appendFormat:@",0x%02x",(unsigned int) c[i]];
            if (i % 8 == 7) [compare1 appendFormat:@"\n"];
        }
    [compare1 appendFormat:@"\n"];
    XCTAssertEqualObjects(compare1, [self stringForTest:@"box"], @"String mismatch");

}

- (void) testBox2 {
    NSMutableString *compare1 = [[NSMutableString alloc ] init];
    unsigned char bobsk[32] = {
        0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b
        ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6
        ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd
        ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb
    } ;
    
    unsigned char alicepk[32] = {
        0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54
        ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a
        ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4
        ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a
    } ;
    
    unsigned char nonce[24] = {
        0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73
        ,0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6
        ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37
    } ;
    
    // API requires first 16 bytes to be 0
    unsigned char c[163] = {
        0,   0,   0,   0,   0,   0,   0,   0
        ,   0,   0,   0,   0,   0,   0,   0,   0
        ,0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5
        ,0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9
        ,0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73
        ,0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce
        ,0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4
        ,0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a
        ,0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b
        ,0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72
        ,0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2
        ,0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38
        ,0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a
        ,0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae
        ,0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea
        ,0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda
        ,0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde
        ,0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3
        ,0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6
        ,0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74
        ,0xe3,0x55,0xa5
    } ;
    
    unsigned char m[163];
    
        int i;
        if (crypto_box_curve25519xsalsa20poly1305_open(
                                                       m,c,163,nonce,alicepk,bobsk
                                                       ) == 0) {
            for (i = 32;i < 163;++i) {
                [compare1 appendFormat:@",0x%02x",(unsigned int) m[i]];
                if (i % 8 == 7) [compare1 appendFormat:@"\n"];
            }
            [compare1 appendFormat:@"\n"];
        }
    XCTAssertEqualObjects(compare1, [self stringForTest:@"box2"], @"String mismatch");

}

-(void) testBox7 {
    
    unsigned char alicesk[crypto_box_SECRETKEYBYTES] = {
        [0] = 0x77 ,
        [1] = 0xc3 ,
        [2] = 0x36 ,
        [3] = 0x07 ,
        [4] = 0x4b ,
        [5] = 0xe9 ,
        [6] = 0xdc ,
        [7] = 0xb6 ,
        [8] = 0x1d ,
        [9] = 0xb6 ,
        [10] = 0x64 ,
        [11] = 0x9f ,
        [12] = 0xfb ,
        [13] = 0xfe ,
        [14] = 0x4c ,
        [15] = 0x08 ,
        [16] = 0x8c ,
        [17] = 0xd9 ,
        [18] = 0xd6 ,
        [19] = 0xff ,
        [20] = 0x59 ,
        [21] = 0xec ,
        [22] = 0xd0 ,
        [23] = 0x92 ,
        [24] = 0xcb ,
        [25] = 0xf6 ,
        [26] = 0xab ,
        [27] = 0xaa ,
        [28] = 0xd5 ,
        [29] = 0x2f ,
        [30] = 0x2e ,
        [31] = 0x40 ,
    };
    unsigned char alicepk[crypto_box_PUBLICKEYBYTES] = {
        [0] = 0x01 ,
        [1] = 0x85 ,
        [2] = 0x56 ,
        [3] = 0x53 ,
        [4] = 0xc9 ,
        [5] = 0x82 ,
        [6] = 0xbd ,
        [7] = 0x14 ,
        [8] = 0xcf ,
        [9] = 0x8a ,
        [10] = 0x14 ,
        [11] = 0xa5 ,
        [12] = 0x16 ,
        [13] = 0x4a ,
        [14] = 0xa5 ,
        [15] = 0x1c ,
        [16] = 0x72 ,
        [17] = 0xdf ,
        [18] = 0x3d ,
        [19] = 0x45 ,
        [20] = 0x20 ,
        [21] = 0x25 ,
        [22] = 0x5b ,
        [23] = 0x76 ,
        [24] = 0x79 ,
        [25] = 0x63 ,
        [26] = 0x68 ,
        [27] = 0x85 ,
        [28] = 0x90 ,
        [29] = 0xe4 ,
        [30] = 0x3b ,
        [31] = 0x5a ,
    };
    
    unsigned char bobsk[crypto_box_SECRETKEYBYTES] = {
        [0] = 0x56 ,
        [1] = 0x5b ,
        [2] = 0x15 ,
        [3] = 0x0f ,
        [4] = 0x17 ,
        [5] = 0x4d ,
        [6] = 0x8d ,
        [7] = 0x8d ,
        [8] = 0x9d ,
        [9] = 0xf7 ,
        [10] = 0x37 ,
        [11] = 0x0f ,
        [12] = 0x70 ,
        [13] = 0xa9 ,
        [14] = 0x57 ,
        [15] = 0x4c ,
        [16] = 0xe5 ,
        [17] = 0x57 ,
        [18] = 0x9c ,
        [19] = 0xb0 ,
        [20] = 0x7b ,
        [21] = 0x32 ,
        [22] = 0x9e ,
        [23] = 0xea ,
        [24] = 0xe0 ,
        [25] = 0x0a ,
        [26] = 0x4e ,
        [27] = 0xd5 ,
        [28] = 0x57 ,
        [29] = 0x3b ,
        [30] = 0x95 ,
        [31] = 0x02 ,
    };
    unsigned char bobpk[crypto_box_PUBLICKEYBYTES] = {
        [0] = 0x90 ,
        [1] = 0x1e ,
        [2] = 0x34 ,
        [3] = 0x43 ,
        [4] = 0xc7 ,
        [5] = 0x4c ,
        [6] = 0xd6 ,
        [7] = 0x2d ,
        [8] = 0x9e ,
        [9] = 0x33 ,
        [10] = 0xbd ,
        [11] = 0x24 ,
        [12] = 0x09 ,
        [13] = 0x23 ,
        [14] = 0xc9 ,
        [15] = 0x07 ,
        [16] = 0x15 ,
        [17] = 0x6f ,
        [18] = 0xd8 ,
        [19] = 0x6c ,
        [20] = 0x1e ,
        [21] = 0xa9 ,
        [22] = 0xc5 ,
        [23] = 0x38 ,
        [24] = 0x3d ,
        [25] = 0xe0 ,
        [26] = 0x24 ,
        [27] = 0x7d ,
        [28] = 0xc5 ,
        [29] = 0x09 ,
        [30] = 0xea ,
        [31] = 0x26 ,
    };
    unsigned char n[crypto_box_NONCEBYTES] = {
        [0] = 0xad ,
        [1] = 0x1e ,
        [2] = 0x3a ,
        [3] = 0x1e ,
        [4] = 0x56 ,
        [5] = 0x69 ,
        [6] = 0xb5 ,
        [7] = 0xbc ,
        [8] = 0xb6 ,
        [9] = 0xcd ,
        [10] = 0x93 ,
        [11] = 0x7c ,
        [12] = 0x3a ,
        [13] = 0x4c ,
        [14] = 0x5f ,
        [15] = 0x39 ,
        [16] = 0x89 ,
        [17] = 0x30 ,
        [18] = 0x1f ,
        [19] = 0xbd ,
        [20] = 0x4b ,
        [21] = 0x50 ,
        [22] = 0x3b ,
        [23] = 0x13 ,
    };
    unsigned char m[10000] = {0}; //see https://github.com/jedisct1/libsodium/issues/117
    unsigned char c[10000];
    unsigned char m2[10000];

        size_t mlen;
        size_t i;
        
        for (mlen = 0;mlen < 1000 && mlen + crypto_box_ZEROBYTES < sizeof m;++mlen) {
            //crypto_box_keypair(alicepk,alicesk);
            //crypto_box_keypair(bobpk,bobsk);
            //randombytes(n,crypto_box_NONCEBYTES);
            randombytes(m + crypto_box_ZEROBYTES,mlen);
            crypto_box(c,m,mlen + crypto_box_ZEROBYTES,n,bobpk,alicesk);
            if (crypto_box_open(m2,c,mlen + crypto_box_ZEROBYTES,n,alicepk,bobsk) == 0) {
                for (i = 0;i < mlen + crypto_box_ZEROBYTES;++i)
                    if (m2[i] != m[i]) {
                        XCTFail(@"bad decryption\n");
                        break;
                    }
            } else {
                XCTFail(@"Cannot decrypt");
            }
        }


}

-(void) testCCBug {
    //verify crypto_onetimeauth
    unsigned char onetimekey[32] = {0xdd,0x5c,0x11,0x07,0x10,0x16,0xe2,0x10
        ,0x47,0x36,0x0e,0xab,0x48,0x81,0x8d,0xcb
        ,0x32,0x20,0xe1,0x1b,0x03,0xc1,0x00,0x40
        ,0xda,0x4c,0xd6,0x59,0x2e,0xbc,0xf1,0x89};
    
    unsigned char ciphertext_pre[16+36] = {0,0,0,0,0,0,0,0
        ,0,0,0,0,0,0,0,0
        ,0x5e,0xfe,0x31,0x64,0xb8,0x55,0x83,0x63
        ,0x22,0x64,0x6f,0xc5,0x23,0x23,0xad,0xaa
        ,0xb2,0x82,0xc1,0x76,0xac,0x87,0x61,0x2b
        ,0xbf,0x0f,0xb7,0x2a,0x4b,0xee,0x90,0xe7
        ,0x08,0xea,0xe0,0x3b};
    
    unsigned char expected_signature[16+36] = {0xbd,0x54,0xc5,0x7f,0x99,0x59,0x97,0xc3
        ,0x95,0xf8,0x55,0x91,0x0c,0x84,0x13,0x47
        ,0x5e,0xfe,0x31,0x64,0xb8,0x55,0x83,0x63
        ,0x22,0x64,0x6f,0xc5,0x23,0x23,0xad,0xaa
        ,0xb2,0x82,0xc1,0x76,0xac,0x87,0x61,0x2b
        ,0xbf,0x0f,0xb7,0x2a,0x4b,0xee,0x90,0xe7
        ,0x08,0xea,0xe0,0x3b};
    
    int result = crypto_onetimeauth_verify(expected_signature, ciphertext_pre+16, 36, onetimekey);
    XCTAssert(result==0, @"Bad result??");
}

-(void) testCaffeineHello {
        //uint8_t secret_key[]  = {0x73,0x54,0x36,0x65,0x72,0x7d,0x6e,0x5a,0x4d,0x2e,0x25,0x62,0x74,0x74,0x42,0x47,0x48,0x42,0x2b,0x46,0x2a,0x38,0x6d,0x72,0x5e,0x4a,0x4a,0x7d,0x72,0x23,0x56,0x3c,0x29,0x64,0x75,0x38,0x4b,0x58,0x75,0x70};
    
    //uint8_t server_publickey[] = {0x2b,0x6d,0x4a,0x24,0x54,0x2f,0x4d,0x74,0x66,0x75,0x64,0x45,0x34,0x61,0x79,0x41,0x4c,0x6e,0x37,0x2e,0x64,0x73,0x2e,0x5e,0x41,0x34,0x40,0x44,0x4c,0x67,0x46,0x77,0x43,0x67,0x4c,0x55,0x29,0x52,0x45,0x56};
    
    uint8_t server_publickey[32];
    uint8_t secret_key[32];
    
    crypto_box_keypair(server_publickey, secret_key);
    uint8_t client_secretkey[32];
    uint8_t client_publickey[32];
    crypto_box_keypair(client_publickey,client_secretkey);
    
    //produce_hello
    uint8_t cn_nonce[8] = {0};
    
    uint8_t c_hello_nonce [crypto_box_NONCEBYTES];
    uint8_t c_hello_plaintext [crypto_box_ZEROBYTES + 64];
    uint8_t c_hello_box [crypto_box_BOXZEROBYTES + 80];
    
    //  Prepare the full nonce
    memcpy (c_hello_nonce, "CurveZMQHELLO---", 16);
    memcpy (c_hello_nonce + 16, &cn_nonce, 8);
    
    //  Create Box [64 * %x0](C'->S)
    memset (c_hello_plaintext, 0, sizeof c_hello_plaintext);
    
    int rc = crypto_box (c_hello_box, c_hello_plaintext,
                         sizeof c_hello_plaintext,
                         c_hello_nonce, server_publickey, client_secretkey);
    XCTAssert(rc==0, @"Crypto box error");
    //  Open Box [64 * %x0](C'->S)
    rc = crypto_box_open (c_hello_plaintext, c_hello_box,
                          sizeof c_hello_box,
                          c_hello_nonce, client_publickey, secret_key);
    if (rc != 0) {
        XCTFail(@"Sodium issue");
    }
    
    uint8_t hello[200];
    
    memcpy (hello, "\x05HELLO", 6);
    //  CurveZMQ major and minor version numbers
    memcpy (hello + 6, "\1\0", 2);
    //  Anti-amplification padding
    memset (hello + 8, 0, 72);
    //  Client public connection key
    memcpy (hello + 80, client_publickey, crypto_box_PUBLICKEYBYTES);
    //  Short nonce, prefixed by "CurveZMQHELLO---"
    memcpy (hello + 112, c_hello_nonce + 16, 8);
    //  Signature, Box [64 * %x0](C'->S)
    memcpy (hello + 120, c_hello_box + crypto_box_BOXZEROBYTES, 80);
    
    //cn_nonce++;
    
    
    
    
    /*uint8_t data[] = {0x05,0x48,0x45,0x4c,0x4c,0x4f,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xb3,0xc3,0x12,0xcb,0xbe,0x5e,0x0c,0x3c,0xd2,0x5f,0x6c,0x34,0x79,0x4c,0xce,0xc6,0x17,0xe4,0x1a,0xc8,0xf9,0x27,0xf7,0xe6,0x08,0xf2,0x1d,0x12,0x92,0xaa,0x7c,0x53,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xb0,0x0b,0xdd,0xed,0xaa,0x80,0x6f,0x85,0x8b,0x40,0x95,0xcc,0x11,0xb0,0x00,0x4c,0xb6,0x72,0xf7,0xf6,0x61,0x0f,0x1e,0x5f,0xa1,0x10,0x9b,0xe7,0x9a,0x86,0xd5,0x75,0x57,0x8f,0x6a,0x6c,0x2f,0x2b,0x27,0xd8,0x06,0x47,0x30,0x70,0x90,0xd7,0x20,0x29,0xb6,0x13,0x42,0x2e,0x3c,0x68,0xfb,0x5b,0xdd,0x95,0xa6,0x18,0xcd,0x8f,0x3b,0x74,0x51,0xd7,0x0a,0x09,0x04,0xa1,0xb9,0x3c,0x08,0x13,0x44,0xc2,0xbc,0xc7,0x66,0x8e};*/
    
    
    /*    const int crypto_box_PUBLICKEYBYTES = 32;
     const int crypto_box_NONCEBYTES = 24;
     const int crypto_box_ZEROBYTES = 32;
     const int crypto_box_BOXZEROBYTES = 16;*/
    
    uint8_t cn_client [crypto_box_PUBLICKEYBYTES];

    
    if (sizeof(hello) != 200) {
        errno = EPROTO;
        XCTFail(@"Bad size");
    }
    
    if (memcmp (hello, "\x05HELLO", 6)) {
        errno = EPROTO;
        XCTFail(@"Bad hello");
    }
    
    const uint8_t major = hello [6];
    const uint8_t minor = hello [7];
    
    if (major != 1 || minor != 0) {
        errno = EPROTO;
        XCTFail(@"Bad version");
    }
    
    //  Save client's short-term public key (C')
    memcpy (cn_client, hello + 80, 32);
    
    uint8_t hello_nonce [crypto_box_NONCEBYTES];
    uint8_t hello_plaintext [crypto_box_ZEROBYTES + 64];
    uint8_t hello_box [crypto_box_BOXZEROBYTES + 80];
    
    memcpy (hello_nonce, "CurveZMQHELLO---", 16);
    memcpy (hello_nonce + 16, hello + 112, 8);
    
    memset (hello_box, 0, crypto_box_BOXZEROBYTES);
    memcpy (hello_box + crypto_box_BOXZEROBYTES, hello + 120, 80);
    printf("crypto_box_BOXZEROBYTES %d\n",crypto_box_BOXZEROBYTES);
    

}

@end
